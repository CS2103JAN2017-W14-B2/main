# A0144904H
###### /java/guitests/EditCommandTest.java
``` java
    @Test
    public void edit_toDoneCategory_failure() {
        commandBox.runCommand("edit 3 c/Done sd/next fri 5pm ed/tomorrow");

        assertResultMessage(EditCommand.ERROR_CANNOT_EDIT_DONE_CATEGORY);
    }

    @Test
    public void edit_doneCategory_failure() throws IllegalArgumentException, IllegalValueException {
        commandBox.runCommand("mark 1");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("edit 1 c/Work");

        assertResultMessage(EditCommand.ERROR_CANNOT_EDIT_DONE_TASK);
    }

    @Test
    public void edit_toAllTasksCategory_failure() {
        commandBox.runCommand("edit 3 c/AllTasks sd/next fri 5pm ed/tomorrow");

        assertResultMessage(EditCommand.ERROR_CANNOT_EDIT_ALL_TASKS_CATEGORY);
    }

```
###### /java/guitests/MarkDoneCommandTest.java
``` java
public class MarkDoneCommandTest extends TaskBossGuiTest {

    // The list of tasks in the task list panel is expected to match this list.
    // This list is updated with every successful call to assertEditSuccess().

    TestTask[] expectedTasksList = td.getTypicalTasks();

    //---------------- Tests for validity of input taskBoss index --------------------------------------

    /*
     * EP: valid task index,
     * should add category "Done" to the task's current category list.
     * - test for long and short command formats
     * - test multiple and single mark done
     */

    //long command format
    //single mark done
    @Test
    public void markDone_validIndexLongCommandFormat_success() throws Exception {
        int taskBossIndex = 1;

        TestTask markedDoneTask = new TaskBuilder().withName("Clean house").withPriorityLevel("Yes")
                .withStartDateTime("Feb 19, 2017 11pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withInformation("wall street").withRecurrence(Frequency.NONE)
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = new TestTask[] {td.taskE, td.taskA, td.taskD, td.taskB, td.taskG, td.taskF};
        TestTask[] expectedDoneTasks = new TestTask[] {markedDoneTask};
        assertMarkDoneSuccess(false, taskBossIndex, taskBossIndex, markedDoneTask, expectedAllTasks, expectedDoneTasks);
    }

    //multiple mark done
    @Test
    public void markDone_multipleValidIndexesLongCommandFormat_success() throws Exception {
        commandBox.runCommand("mark 4 5");

        expectedTasksList[4] = new TaskBuilder().withName("Birthday party")
                .withInformation("311, Clementi Ave 2, #02-25")
                .withPriorityLevel("No")
                .withRecurrence(Frequency.NONE)
                .withStartDateTime("Feb 23, 2017 10pm")
                .withEndDateTime("Jun 28, 2017 5pm")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS,
                        "Friends", "Owesmoney").build();

        expectedTasksList[3] = new TaskBuilder().withName("Debug code").withPriorityLevel("Yes")
                .withStartDateTime("Feb 20, 2017 11.30pm")
                .withEndDateTime("Apr 28, 2017 3pm")
                .withRecurrence(Frequency.NONE)
                .withInformation("10th street")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedDoneTasks = new TestTask[] {expectedTasksList[4], expectedTasksList[3]};
        TestTask[] expectedAllTasks = {td.taskC, td.taskE, td.taskA, td.taskG, td.taskF};


        assertTrue(taskListPanel.isListMatching(expectedAllTasks));

        assertResultMessage(String.format(MarkDoneCommand.MESSAGE_MARK_TASK_DONE_SUCCESS,
                getDesiredFormat(expectedDoneTasks)));
    }

    //short command format
    //single mark done
    @Test
    public void markDone_validIndexShortCommandFormat_success() throws Exception {
        int taskBossIndex = 1;

        TestTask markedDoneTask = new TaskBuilder().withName("Clean house").withPriorityLevel("Yes")
                .withStartDateTime("Feb 19, 2017 11pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withInformation("wall street").withRecurrence(Frequency.NONE)
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = new TestTask[] {td.taskE, td.taskA, td.taskD, td.taskB, td.taskG, td.taskF};
        TestTask[] expectedDoneTasks = new TestTask[] {markedDoneTask};
        assertMarkDoneSuccess(true, taskBossIndex, taskBossIndex, markedDoneTask, expectedAllTasks, expectedDoneTasks);
    }

    //multiple mark done
    @Test
    public void markDone_multipleValidIndexesShortCommandFormat_success() throws Exception {
        commandBox.runCommand("m 4 5");

        expectedTasksList[4] = new TaskBuilder().withName("Birthday party")
                .withInformation("311, Clementi Ave 2, #02-25")
                .withPriorityLevel("No")
                .withRecurrence(Frequency.NONE)
                .withStartDateTime("Feb 23, 2017 10pm")
                .withEndDateTime("Jun 28, 2017 5pm")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS,
                        "Friends", "Owesmoney").build();

        expectedTasksList[3] = new TaskBuilder().withName("Debug code").withPriorityLevel("Yes")
                .withStartDateTime("Feb 20, 2017 11.30pm")
                .withEndDateTime("Apr 28, 2017 3pm")
                .withRecurrence(Frequency.NONE)
                .withInformation("10th street")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedDoneTasks = new TestTask[] {expectedTasksList[4], expectedTasksList[3]};
        TestTask[] expectedAllTasks = {td.taskC, td.taskE, td.taskA, td.taskG, td.taskF};

        assertTrue(taskListPanel.isListMatching(expectedAllTasks));

        assertResultMessage(String.format(MarkDoneCommand.MESSAGE_MARK_TASK_DONE_SUCCESS,
                getDesiredFormat(expectedDoneTasks)));
    }


    /*
     * EP: missing task index,
     * should show error message: invalid command format
     * and display a message demonstrating the correct way to write the command
     */
    @Test
    public void markDone_missingTaskIndex_failure() {
        //long command format
        commandBox.runCommand("mark ");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));

        //short command format
        commandBox.runCommand("m ");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));
    }

    /*
     * EP: invalid task index,
     * should show error message: invalid index
     * - test short and long command format
     * - test multiple and single mark done
     */

    //single mark done
    @Test
    public void markDone_invalidTaskIndex_failure() {

        //long command format

        commandBox.runCommand("mark 9");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("mark -1");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        // non-numeric inputs
        commandBox.runCommand("mark ^");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));

        commandBox.runCommand("mark b");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));

        //short command format

        commandBox.runCommand("m 10");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("m 0");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        // non-numeric inputs
        commandBox.runCommand("m ^");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));

        commandBox.runCommand("m b");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));
    }

    //multiple mark done
    @Test
    public void markDone_multipleInvalidIndexes_failure() {
        //long command format
        commandBox.runCommand("mark 1 2 100");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("mark 0 2 3");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        //user inputs non-numeric index values
        commandBox.runCommand("mark a 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));

        commandBox.runCommand("mark ; 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));

        //short command format
        commandBox.runCommand("m 1 2 100");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("m 0 2 3");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        //user inputs non-numeric index values
        commandBox.runCommand("m a 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));

        commandBox.runCommand("m ; 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkDoneCommand.MESSAGE_USAGE));
    }

    //---------------- Tests for corner cases --------------------------------------------------------

    /*
     * EP: marking a marked task,
     * should show error message: cannot mark marked tasks
     * - test short and long command format
     * - test multiple and single mark done
     */

    //long command format

    //single mark done
    @Test
    public void markDone_taskMarkedDoneLongCommandFormat_failure() {
        commandBox.runCommand("mark 1");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("mark 1");
        assertResultMessage(MarkDoneCommand.ERROR_MARKED_TASK);
    }

    //multiple mark done
    @Test
    public void markDone_multipleTaskMarkedDoneLongCommandFormat_failure() {
        commandBox.runCommand("mark 1 4");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("mark 1 2");
        assertResultMessage(MarkDoneCommand.ERROR_MARKED_TASK);
    }

    //short command format

    //single mark done
    @Test
    public void markDone_taskMarkedDoneShortCommandFormat_failure() {
        commandBox.runCommand("m 1");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("m 1");
        assertResultMessage(MarkDoneCommand.ERROR_MARKED_TASK);
    }

    //multiple mark done
    @Test
    public void markDone_multipleTaskMarkedDoneShortCommandFormat_failure() {
        commandBox.runCommand("m 1 5");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("m 1 2");
        assertResultMessage(MarkDoneCommand.ERROR_MARKED_TASK);
    }

    /*
     * EP: marking multiple tasks with spaces between indexes,
     * should add category "Done" to all the tasks's current category lists.
     */
    @Test
    public void marDone_SpacesInBetweenIndexes_success() throws Exception {
        commandBox.runCommand("mark 5       4 ");
        expectedTasksList[4] = new TaskBuilder().withName("Birthday party")
                .withInformation("311, Clementi Ave 2, #02-25")
                .withPriorityLevel("No")
                .withRecurrence(Frequency.NONE)
                .withStartDateTime("Feb 23, 2017 10pm")
                .withEndDateTime("Jun 28, 2017 5pm")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS,
                                    "Friends", "Owesmoney").build();

        expectedTasksList[3] = new TaskBuilder().withName("Debug code").withPriorityLevel("Yes")
                .withStartDateTime("Feb 20, 2017 11.30pm")
                .withEndDateTime("Apr 28, 2017 3pm")
                .withRecurrence(Frequency.NONE)
                .withInformation("10th street")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedDoneTasks = new TestTask[] {expectedTasksList[4], expectedTasksList[3]};
        TestTask[] expectedAllTasks = {td.taskC, td.taskE, td.taskA, td.taskG, td.taskF};

        assertTrue(taskListPanel.isListMatching(expectedAllTasks));

        assertResultMessage(String.format(MarkDoneCommand.MESSAGE_MARK_TASK_DONE_SUCCESS,
                getDesiredFormat(expectedDoneTasks)));
    }

    //---------------- Tests mark done after find command -----------------------------------------

    /*
     * EP: marking after finding a task,
     * should add category "Done" to the task's current category list.
     */
    @Test
    public void markDone_findThenMarkDone_success() throws Exception {
        commandBox.runCommand("find Clean house");

        int filteredTaskListIndex = 1;
        int taskBossIndex = 1;

        TestTask taskToMarkDone = expectedTasksList[taskBossIndex - 1];
        TestTask markedDoneTask = new TaskBuilder(taskToMarkDone).withCategories(AddCommand.BUILT_IN_DONE,
                AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedDoneTasks = new TestTask[] {markedDoneTask};

        assertMarkDoneSuccess(false, filteredTaskListIndex, taskBossIndex, markedDoneTask,
                expectedDoneTasks, expectedDoneTasks);
    }

    //---------------- Test for different types of tasks --------------------------------------


    /*
     * EP: marking non-recurring task,
     * should add category "Done" to the task's current category list.
     */
    @Test
    public void markDone_markNonRecurringTask_success() throws Exception {
        int taskBossIndex = 1;

        TestTask markedDoneTask = new TaskBuilder().withName("Clean house").withPriorityLevel("Yes")
                .withStartDateTime("Feb 19, 2017 11pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withInformation("wall street").withRecurrence(Frequency.NONE)
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = new TestTask[] {td.taskE, td.taskA, td.taskD, td.taskB, td.taskG, td.taskF};
        TestTask[] expectedDoneTasks = new TestTask[] {markedDoneTask};
        assertMarkDoneSuccess(false, taskBossIndex, taskBossIndex, markedDoneTask,
                expectedAllTasks, expectedDoneTasks);
    }

    /*
     * EP: marking recurring task,
     * should update task's dates based on recurrence type.
     */
    @Test

    public void markDone_markRecurringTask_success() throws Exception {
        commandBox.runCommand("mark 2");
        TestTask markedDoneTask =  new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Mar 22, 2017 5pm")
                .withEndDateTime("Mar 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();
        TestTask[] expectedAllTasks = expectedTasksList;
        expectedAllTasks[1] = markedDoneTask;

        assertTrue(taskListPanel.isListMatching(expectedAllTasks));

        assertResultMessage(String.format(MarkDoneCommand.MESSAGE_MARK_TASK_DONE_SUCCESS,
                getDesiredFormat(new TestTask[] {markedDoneTask})));
    }

    /*
     * EP: marking recurring and non-recurring tasks at the same time,
     * should update the recurring task's dates based on recurrence type.
     * should add category "Done" to the non-recurring task's current category list.
     */
    @Test
    public void markDone_markMixTypesOfTasks_success() throws Exception {

        commandBox.runCommand("mark 2 4");

        // recurring
        TestTask markedDone1 = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Mar 22, 2017 5pm")
                .withEndDateTime("Mar 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();

        //non recurring
        TestTask markedDone2 = new TaskBuilder().withName("Debug code").withPriorityLevel("Yes")
                .withStartDateTime("Feb 20, 2017 11.30pm")
                .withEndDateTime("Apr 28, 2017 3pm")
                .withRecurrence(Frequency.NONE)
                .withInformation("10th street")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = {td.taskC, td.taskE, td.taskA, td.taskB, td.taskG, td.taskF};
        expectedAllTasks[1] = markedDone1;
        TestTask[] markedDone = new TestTask[] {markedDone2, markedDone1};

        assertTrue(taskListPanel.isListMatching(expectedAllTasks));
        assertResultMessage(String.format(MarkDoneCommand.MESSAGE_MARK_TASK_DONE_SUCCESS,
                getDesiredFormat(markedDone)));
    }

    //---------------- End of test cases --------------------------------------

```
###### /java/guitests/RenameCategoryCommandTest.java
``` java
public class RenameCategoryCommandTest extends TaskBossGuiTest {

    @Test
    public void renameCategory_LongCommand_success() throws IllegalValueException {
        assertRenameCategoryResult("name friends Project");
    }

    @Test
    public void renameCategory_ShortCommand_success() throws IllegalValueException {
        assertRenameCategoryResult("n friends Project");
    }

    private void assertRenameCategoryResult(String command) throws IllegalValueException {
        TestTask sampleA;
        TestTask sampleB;
        sampleA = new TaskBuilder().withName("Attend wedding")
                .withInformation("123, Jurong West Ave 6, #08-111")
                .withPriorityLevel("Yes")
                .withStartDateTime("Feb 18, 2017 5pm")
                .withEndDateTime("Mar 28, 2017 5pm")
                .withRecurrence(Frequency.NONE)
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS, "Project").build();
        sampleB = new TaskBuilder().withName("Birthday party")
                .withInformation("311, Clementi Ave 2, #02-25")
                .withPriorityLevel("No")
                .withStartDateTime("Feb 23, 2017 10pm")
                .withEndDateTime("Jun 28, 2017 5pm")
                .withRecurrence(Frequency.NONE)
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS, "Project", "Owesmoney").build();

        TestTask[] taskListExpected = {sampleA, sampleB};
        commandBox.runCommand(command);
        assertResultMessage(RenameCategoryCommand.MESSAGE_SUCCESS);
        assertTrue(taskListPanel.isListMatching(taskListExpected));
    }

    @Test
    public void rename_unsuccessful() {

        //old category name == new category name
        commandBox.runCommand("name friends friends");
        assertResultMessage(RenameCategoryCommandParser.ERROR_SAME_FIELDS);

        //invalid number of fields
        commandBox.runCommand("name friends bestfriends forever");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, RenameCategoryCommand.MESSAGE_USAGE));

        //category name with a single non-alphanumerical character
        commandBox.runCommand("name owesMoney myMoney!");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                RenameCategoryCommandParser.ERROR_NON_ALPHANUMERIC));

        //category name with all non-alphanumerical characters
        commandBox.runCommand("name owesMoney !!!");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                RenameCategoryCommandParser.ERROR_NON_ALPHANUMERIC));

        //category name does not exist
        commandBox.runCommand("name superman batman");
        assertResultMessage("[Superman] " + RenameCategoryCommand.MESSAGE_DOES_NOT_EXIST_CATEGORY);

        //category name is AllTasks
        commandBox.runCommand("name AllTasks batman");
        assertResultMessage(RenameCategoryCommand.MESSAGE_ALL_TASK_CATEGORY_CANNOT_RENAME);

        //category name is Done
        commandBox.runCommand("name Done batman");
        assertResultMessage(RenameCategoryCommand.MESSAGE_DONE_CATEGORY_CANNOT_RENAME);

        //rename category to Done
        commandBox.runCommand("name owesMoney Done");
        assertResultMessage(RenameCategoryCommand.MESSAGE_CATEGORY_CANNOT_RENAME_TO_DONE);

        //rename category to AllTasks
        commandBox.runCommand("name owesMoney AllTasks");
        assertResultMessage(RenameCategoryCommand.MESSAGE_CATEGORY_CANNOT_RENAME_TO_ALL_TASKS);
    }

```
###### /java/guitests/TerminateCommandTest.java
``` java
public class TerminateCommandTest extends TaskBossGuiTest {

    // The list of tasks in the task list panel is expected to match this list.
    // This list is updated with every successful call to assertEditSuccess().
    private TestTask[] expectedTasksList = td.getTypicalTasks();

  //---------------- Tests for validity of input taskBoss index --------------------------------------

    /*
     * EP: valid task index,
     * should add category "Done" to the recurring task's current category list.
     * - test for long and short command formats
     * - test multiple and single terminate
     */

    //long command format
    //single terminate
    @Test
    public void terminate_validIndexLongCommandformat_success() throws Exception {
        int taskBossIndex = 2;

        TestTask terminatedTask = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Feb 22, 2017 5pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = {td.taskC, td.taskA, td.taskD, td.taskB, td.taskG, td.taskF};
        TestTask[] expectedTerminatedTasks = {terminatedTask};
        assertTerminateSuccess(false, taskBossIndex, taskBossIndex, terminatedTask,
                expectedAllTasks, expectedTerminatedTasks);
    }

    //multiple terminate
    @Test
    public void terminate_multipleValidIndexesLongCommandformat_success() throws Exception {
        commandBox.runCommand("terminate 2 7");

        expectedTasksList[1] = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Feb 22, 2017 5pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        expectedTasksList[6] = new TaskBuilder().withName("Fix errors in report").withPriorityLevel("No")
                .withStartDateTime("Feb 21, 2017 1pm")
                .withEndDateTime("Dec 10, 2017 5pm")
                .withRecurrence(Frequency.WEEKLY)
                .withInformation("little tokyo")
                .withCategories("School", AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = {td.taskC, td.taskA, td.taskD, td.taskB, td.taskG};
        assertTrue(taskListPanel.isListMatching(expectedAllTasks));
        TestTask[] terminatedTasks = new TestTask[] {expectedTasksList[6], expectedTasksList[1]};
        assertResultMessage(String.format(TerminateCommand.MESSAGE_MARK_RECURRING_TASK_DONE_SUCCESS,
                getDesiredFormat(terminatedTasks)));
    }

    //short command format
    //single terminate
    @Test
    public void terminate_validIndexShortCommandformat_success() throws Exception {
        int taskBossIndex = 2;

        TestTask terminatedTask = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Feb 22, 2017 5pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = {td.taskC, td.taskA, td.taskD, td.taskB, td.taskG, td.taskF};
        TestTask[] expectedTerminatedTasks = {terminatedTask};
        assertTerminateSuccess(true, taskBossIndex, taskBossIndex, terminatedTask,
                expectedAllTasks, expectedTerminatedTasks);
    }

    //multiple terminate
    @Test
    public void terminate_multipleValidIndexesShortCommandformat_success() throws Exception {
        commandBox.runCommand("t 2 7");

        expectedTasksList[1] = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Feb 22, 2017 5pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        expectedTasksList[6] = new TaskBuilder().withName("Fix errors in report").withPriorityLevel("No")
                .withStartDateTime("Feb 21, 2017 1pm")
                .withEndDateTime("Dec 10, 2017 5pm")
                .withRecurrence(Frequency.WEEKLY)
                .withInformation("little tokyo")
                .withCategories("School", "Done", AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = {td.taskC, td.taskA, td.taskD, td.taskB, td.taskG};
        assertTrue(taskListPanel.isListMatching(expectedAllTasks));
        TestTask[] terminatedTasks = new TestTask[] {expectedTasksList[6], expectedTasksList[1]};
        assertResultMessage(String.format(TerminateCommand.MESSAGE_MARK_RECURRING_TASK_DONE_SUCCESS,
                getDesiredFormat(terminatedTasks)));
    }


    /*
     * EP: missing task index,
     * should show error message: invalid command format
     * and display a message demonstrating the correct way to write the command
     */
    @Test
    public void terminate_missingTaskIndex_failure() {
        //long command format
        commandBox.runCommand("terminate ");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));

        //short command format
        commandBox.runCommand("t ");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));
    }

    /*
     * EP: invalid task index,
     * should show error message: invalid index
     * - test short and long command format
     * - test multiple and single terminate
     */

    //single terminate
    @Test
    public void terminate_invalidTaskIndex_failure() {

        //long command format

        commandBox.runCommand("terminate 9");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("terminate -1");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        // non-numeric inputs
        commandBox.runCommand("terminate ^");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));

        commandBox.runCommand("terminate b");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));

        //short command format

        commandBox.runCommand("t 10");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("t 0");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        // non-numeric inputs
        commandBox.runCommand("t ^");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));

        commandBox.runCommand("t b");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));
    }

    //multiple terminate
    @Test
    public void terminate_multipleInvalidIndexes_failure() {
        //long command format
        commandBox.runCommand("terminate 1 2 100");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("terminate 0 2 3");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        //user inputs non-numeric index values
        commandBox.runCommand("terminate a 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));

        commandBox.runCommand("terminate ; 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));

        //short command format
        commandBox.runCommand("t 1 2 100");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("t 0 2 3");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        //user inputs non-numeric index values
        commandBox.runCommand("t a 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));

        commandBox.runCommand("t ; 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TerminateCommand.MESSAGE_USAGE));
    }

    //---------------- Tests for corner cases --------------------------------------------------------

    /*
     * EP: terminating a terminated task,
     * should show error message: cannot terminate terminated tasks
     * - test short and long command format
     * - test multiple and single terminate
     */

    //long command format

    //single terminate
    @Test
    public void terminate_taskTerminatedLongCommandFormat_failure() {
        commandBox.runCommand("terminate 2");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("terminate 1");
        assertResultMessage(TerminateCommand.ERROR_TERMINATED_TASK);
    }

    @Test
    public void terminate_multinpleTaskTerminatedLongCommandFormat_failure() {
        commandBox.runCommand("terminate 2 7");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("terminate 1 2");
        assertResultMessage(TerminateCommand.ERROR_TERMINATED_TASK);
    }

    //long command format

    //single terminate
    @Test
    public void terminate_taskTerminatedShortCommandFormat_failure() {
        commandBox.runCommand("terminate 2");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("terminate 1");
        assertResultMessage(TerminateCommand.ERROR_TERMINATED_TASK);
    }

    @Test
    public void terminate_multinpleTaskTerminatedShortCommandFormat_failure() {
        commandBox.runCommand("terminate 2 7");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("terminate 1 2");
        assertResultMessage(TerminateCommand.ERROR_TERMINATED_TASK);
    }

    /*
     * EP: terminating multiple recurring tasks with spaces between indexes,
     * should add category "Done" to all the tasks's current category lists.
     */
    @Test
    public void terminate_SpacesInBetweenIndexes_success() throws Exception {
        commandBox.runCommand("t 2       6 ");
        expectedTasksList[1] = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Feb 22, 2017 5pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories("Done", AddCommand.BUILT_IN_ALL_TASKS).build();
        expectedTasksList[5] = new TaskBuilder().withName("Game project player testing").withPriorityLevel("Yes")
                .withStartDateTime("Jan 1, 2017 5pm")
                .withEndDateTime("Nov 28, 2017 5pm")
                .withRecurrence(Frequency.DAILY)
                .withInformation("4th street")
                .withCategories("Done", AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = {td.taskC, td.taskA, td.taskD, td.taskB, td.taskF};
        assertTrue(taskListPanel.isListMatching(expectedAllTasks));
        TestTask[] terminatedTasks = new TestTask[] {expectedTasksList[5], expectedTasksList[1]};
        assertResultMessage(String.format(TerminateCommand.MESSAGE_MARK_RECURRING_TASK_DONE_SUCCESS,
                getDesiredFormat(terminatedTasks)));
    }

    //---------------- Tests terminate after find command -----------------------------------------

    /*
     * EP: terminating after finding a task,
     * should add category "Done" to the task's current category list.
     */
    @Test
    public void terminate_findThenTerminate_success() throws Exception {
        commandBox.runCommand("find ensure");

        int filteredTaskListIndex = 1;
        int taskBossIndex = 2;

        TestTask taskToMarkDone = expectedTasksList[taskBossIndex - 1];
        TestTask markedDoneTask = new TaskBuilder(taskToMarkDone).withCategories(AddCommand.BUILT_IN_DONE,
                AddCommand.BUILT_IN_ALL_TASKS).build();
        TestTask[] expectedDoneTasks = { markedDoneTask };

        assertTerminateSuccess(false, filteredTaskListIndex, taskBossIndex, markedDoneTask,
                expectedDoneTasks, expectedDoneTasks);
    }

    //---------------- Test for different types of tasks --------------------------------------


    /*
     * EP: terminating non-recurring task,
     * should show message: cannot terminate a non-recurring task.
     */
    @Test
    public void terminate_nonRecurringTask_failure() throws Exception {
        commandBox.runCommand("t 1");
        assertResultMessage(TerminateCommand.ERROR_TASK_NOT_RECURRING);
    }

    /*
     * EP: terminating recurring task,
     * should add category "Done" to the task's current category list.
     */
    @Test
    public void terminate_recurringTask_success() throws Exception {
        int taskBossIndex = 2;
        TestTask markedDoneTask =  new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Feb 22, 2017 5pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_DONE, AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = {td.taskC, td.taskA, td.taskD, td.taskB, td.taskG, td.taskF};
        TestTask[] expectedDoneTasks = { markedDoneTask };
        assertTerminateSuccess(false, taskBossIndex, taskBossIndex, markedDoneTask,
                expectedAllTasks, expectedDoneTasks);
    }

    /*
     * EP: terminating recurring and non-recurring tasks at the same time,
     * should show message: cannot terminate a non-recurring task.
     */
    @Test
    public void terminate_mixTypesOfTasks_failure() throws Exception {
        commandBox.runCommand("t 2 4");
        assertResultMessage(TerminateCommand.ERROR_TASK_NOT_RECURRING);
    }

    //---------------- End of test cases --------------------------------------

    private void assertTerminateSuccess(boolean isShort, int filteredTaskListIndex, int taskBossIndex,
            TestTask terminatedTask, TestTask[] expectedAllTasks, TestTask[] expectedDoneTasks) {

```
###### /java/guitests/TerminateCommandTest.java
``` java
        if (isShort) {
            commandBox.runCommand("t " + filteredTaskListIndex);
        } else {
            commandBox.runCommand("terminate " + filteredTaskListIndex);
        }

        // confirm the Alltasks category now does not contain the terminatedTask
        assertTrue(taskListPanel.isListMatching(expectedAllTasks));
        assertResultMessage(String.format(TerminateCommand.MESSAGE_MARK_RECURRING_TASK_DONE_SUCCESS, "1. " +
                terminatedTask));

        // confirm the Done category now contains the terminatedTask
        commandBox.runCommand("list c/done");
        assertTrue(taskListPanel.isListMatching(expectedDoneTasks));
    }

```
###### /java/guitests/UnmarkCommandTest.java
``` java
public class UnmarkCommandTest extends TaskBossGuiTest {

    // The list of tasks in the task list panel is expected to match this list.
    // This list is updated with every successful call to assertEditSuccess().
    private TestTask[] expectedTasksList = td.getTypicalTasks();

  //---------------- Tests for validity of input taskBoss index --------------------------------------

    /*
     * EP: valid task index,
     * should remove Done category from all tasks' current category lists.
     * - test for long and short command formats
     * - test multiple and single unmark
     */

    //long command format

    //single unmark
    @Test
    public void unmark_validIndexLongCommandFormat_success() throws Exception {
        int taskBossIndex = 2;
        int filteredTaskListIndex = 1;
        String commandType = "termination";

        TestTask unmarkedTask = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Mar 22, 2017 5pm")
                .withEndDateTime("Mar 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();
        TestTask[] expectedAllTasks = expectedTasksList;
        expectedAllTasks[1] = unmarkedTask;

        assertUnmarkSuccess(commandType, false, filteredTaskListIndex, taskBossIndex,
                unmarkedTask, expectedAllTasks);
    }

    //multiple unmark
    @Test
    public void unmark_multipleValidIndexesLongCommandFormat_success() throws Exception {
        commandBox.runCommand("m 4 5");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("unmark 1           2");
        expectedTasksList[3] = new TaskBuilder().withName("Debug code").withPriorityLevel("Yes")
                .withStartDateTime("Feb 20, 2017 11.30pm")
                .withEndDateTime("Apr 28, 2017 3pm")
                .withRecurrence(Frequency.NONE)
                .withInformation("10th street")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();
        expectedTasksList[4] = new TaskBuilder().withName("Birthday party")
                .withInformation("311, Clementi Ave 2, #02-25")
                .withPriorityLevel("No")
                .withRecurrence(Frequency.NONE)
                .withStartDateTime("Feb 23, 2017 10pm")
                .withEndDateTime("Jun 28, 2017 5pm")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS, "Friends", "Owesmoney").build();

        TestTask[] unmarked = new TestTask[] {expectedTasksList[4], expectedTasksList[3]};
        assertResultMessage(String.format(UnmarkCommand.MESSAGE_UNMARK_TASK_DONE_SUCCESS,
                getDesiredFormat(unmarked)));

        commandBox.runCommand("list");
        assertTrue(taskListPanel.isListMatching(expectedTasksList));

    }

    //short command format

    //single unmark
    @Test
    public void unmark_validIndexSshortCommandFormat_success() throws Exception {
        int taskBossIndex = 2;
        int filteredTaskListIndex = 1;
        String commandType = "termination";

        TestTask unmarkedTask = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Mar 22, 2017 5pm")
                .withEndDateTime("Mar 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] expectedAllTasks = expectedTasksList;
        expectedAllTasks[1] = unmarkedTask;

        assertUnmarkSuccess(commandType, false, filteredTaskListIndex, taskBossIndex,
                unmarkedTask, expectedAllTasks);
    }

    //multiple unmark
    @Test
    public void unmark_multipleValidIndexesShortCommandFormat_success() throws Exception {
        commandBox.runCommand("m 4 5");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("um 1           2");
        expectedTasksList[3] = new TaskBuilder().withName("Debug code").withPriorityLevel("Yes")
                .withStartDateTime("Feb 20, 2017 11.30pm")
                .withEndDateTime("Apr 28, 2017 3pm")
                .withRecurrence(Frequency.NONE)
                .withInformation("10th street")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();
        expectedTasksList[4] = new TaskBuilder().withName("Birthday party")
                .withInformation("311, Clementi Ave 2, #02-25")
                .withPriorityLevel("No")
                .withRecurrence(Frequency.NONE)
                .withStartDateTime("Feb 23, 2017 10pm")
                .withEndDateTime("Jun 28, 2017 5pm")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS, "Friends", "Owesmoney").build();

        TestTask[] unmarked = new TestTask[] {expectedTasksList[4], expectedTasksList[3]};
        assertResultMessage(String.format(UnmarkCommand.MESSAGE_UNMARK_TASK_DONE_SUCCESS,
                getDesiredFormat(unmarked)));

        commandBox.runCommand("list");
        assertTrue(taskListPanel.isListMatching(expectedTasksList));
    }


    /*
     * EP: missing task index,
     * should show error message: invalid command format
     * and display a message demonstrating the correct way to write the command
     */
    @Test
    public void unmark_missingTaskIndex_failure() {
        //long command format
        commandBox.runCommand("unmark ");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));

        //short command format
        commandBox.runCommand("um ");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
    }

    /*
     * EP: invalid task index,
     * should show error message: invalid index
     * - test short and long command format
     * - test multiple and single unmark
     */

    //single unmark
    @Test
    public void unmark_invalidTaskIndex_failure() {

        //long command format

        commandBox.runCommand("unmark 9");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("unmark -1");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        // non-numeric inputs
        commandBox.runCommand("unmark ^");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));

        commandBox.runCommand("unmark b");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));

        //short command format

        commandBox.runCommand("um 10");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("um 0");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        // non-numeric inputs
        commandBox.runCommand("um ^");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));

        commandBox.runCommand("um b");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
    }

    //multiple unmark
    @Test
    public void unmark_multipleInvalidIndexes_failure() {
        //long command format
        commandBox.runCommand("unmark 1 2 100");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("unmark 0 2 3");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        //user inputs non-numeric index values
        commandBox.runCommand("unmark a 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));

        commandBox.runCommand("unmark ; 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));

        //short command format
        commandBox.runCommand("um 1 2 100");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("um 0 2 3");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        //user inputs non-numeric index values
        commandBox.runCommand("um a 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));

        commandBox.runCommand("um ; 2 3");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
    }

    //---------------- Tests for corner cases --------------------------------------------------------

    /*
     * EP: unmarking multiple tasks with spaces between indexes,
     * should remove Done category from all tasks' current category lists.
     */
    @Test
    public void unmark_SpacesInBetweenIndexes_success() throws Exception {
        commandBox.runCommand("m 4 5");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("um 1           2");
        expectedTasksList[3] = new TaskBuilder().withName("Debug code").withPriorityLevel("Yes")
                .withStartDateTime("Feb 20, 2017 11.30pm")
                .withEndDateTime("Apr 28, 2017 3pm")
                .withRecurrence(Frequency.NONE)
                .withInformation("10th street")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();
        expectedTasksList[4] = new TaskBuilder().withName("Birthday party")
                .withInformation("311, Clementi Ave 2, #02-25")
                .withPriorityLevel("No")
                .withRecurrence(Frequency.NONE)
                .withStartDateTime("Feb 23, 2017 10pm")
                .withEndDateTime("Jun 28, 2017 5pm")
                .withCategories("Alltasks", "Friends", "Owesmoney").build();

        TestTask[] markedDone = new TestTask[] {expectedTasksList[4], expectedTasksList[3]};
        assertResultMessage(String.format(UnmarkCommand.MESSAGE_UNMARK_TASK_DONE_SUCCESS,
                getDesiredFormat(markedDone)));

        commandBox.runCommand("list");
        assertTrue(taskListPanel.isListMatching(expectedTasksList));
    }

    //---------------- Tests unmark done after find command -----------------------------------------

    /*
     * EP: unmarking after finding a task,
     * should remove Done category from all tasks' current category lists.
     */
    @Test
    public void unmark_findThenUnmark_success() throws Exception {
        commandBox.runCommand("find clean");
        String commandType = "marking";

        int filteredTaskListIndex = 1;
        int taskBossIndex = 1;

        TestTask taskToUnmark = expectedTasksList[taskBossIndex - 1];
        TestTask unmarkedTask = new TaskBuilder(taskToUnmark).build();

        assertUnmarkSuccess(commandType, false, filteredTaskListIndex,
                taskBossIndex, unmarkedTask, expectedTasksList);
    }

    //---------------- Test for different types of tasks --------------------------------------


    /*
     * EP: unmarking non-recurring task,
     * should remove Done category from all tasks' current category lists.
     */
    @Test
    public void unmark_nonRecurringTask_success() throws Exception {
        int taskBossIndex = 1;
        String commandType = "marking";

        TestTask unmarkedTask = new TaskBuilder().withName("Clean house").withPriorityLevel("Yes")
                .withStartDateTime("Feb 19, 2017 11pm")
                .withEndDateTime("Feb 28, 2017 5pm")
                .withInformation("wall street").withRecurrence(Frequency.NONE)
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();

        assertUnmarkSuccess(commandType, false, taskBossIndex,
                taskBossIndex, unmarkedTask, expectedTasksList);
    }

    /*
     * EP: unmarking recurring task,
     * should remove Done category from all tasks' current category lists
     * and should update date of task according to recurrance type
     */
    @Test
    public void unmark_recurringTask_success() throws Exception {
        int taskBossIndex = 2;
        int filteredTaskListIndex = 1;
        String commandType = "termination";

        TestTask unmarkedTask =  new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Mar 22, 2017 5pm")
                .withEndDateTime("Mar 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();

        expectedTasksList[1] = unmarkedTask;
        assertUnmarkSuccess(commandType, false, filteredTaskListIndex,
                taskBossIndex, unmarkedTask, expectedTasksList);
    }

    /*
     * EP: unmarking recurring and non-recurring tasks at the same time,
     * should update the recurring task's dates based on recurrence type.
     * and should remove Done category from all tasks' current category lists
     */
    @Test
    public void unmark_mixTypesOfTasks_success() throws Exception {
        commandBox.runCommand("terminate 2");
        commandBox.runCommand("mark 3");
        commandBox.runCommand("list c/done");
        commandBox.runCommand("unmark 1 2");

        // recurring
        expectedTasksList[1] = new TaskBuilder().withName("Ensure code quality").withPriorityLevel("No")
                .withStartDateTime("Mar 22, 2017 5pm")
                .withEndDateTime("Mar 28, 2017 5pm")
                .withRecurrence(Frequency.MONTHLY)
                .withInformation("michegan ave")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();

        //non recurring
        expectedTasksList[3] = new TaskBuilder().withName("Debug code").withPriorityLevel("Yes")
                .withStartDateTime("Feb 20, 2017 11.30pm")
                .withEndDateTime("Apr 28, 2017 3pm")
                .withRecurrence(Frequency.NONE)
                .withInformation("10th street")
                .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();

        TestTask[] markedDone = new TestTask[] {expectedTasksList[3], expectedTasksList[1]};
        assertResultMessage(String.format(UnmarkCommand.MESSAGE_UNMARK_TASK_DONE_SUCCESS,
                getDesiredFormat(markedDone)));
        commandBox.runCommand("list");
        assertTrue(taskListPanel.isListMatching(expectedTasksList));
    }

    //---------------- Tests for inputing wrong task type--------------------------------------------------------

    /*
     * EP: task is not in Done category
     * should show error message: cannot unmark a task that is not in the done category
     * - test for marked and terminated tasks
     */

    //not marked task
    @Test
    public void unmark_NotMarkedDone_failure() {
        commandBox.runCommand("um 1");
        assertResultMessage(UnmarkCommand.ERROR_NOT_MARKED);
    }

    //not terminated task
    @Test
    public void unmark_NotTerminated_failure() {
        commandBox.runCommand("um 2");
        assertResultMessage(UnmarkCommand.ERROR_NOT_MARKED);
    }

    //---------------- End of test cases --------------------------------------

    private void assertUnmarkSuccess(String commandType, boolean isShort,
            int filteredTaskListIndex, int taskBossIndex,
            TestTask terminatedTask, TestTask[] expectedAllTasks) {

        if (commandType.equals("termination")) {
            if (isShort) {
                commandBox.runCommand("t " + taskBossIndex);
                commandBox.runCommand("list c/done");
                commandBox.runCommand("um " + filteredTaskListIndex);
            } else {
                commandBox.runCommand("t " + taskBossIndex);
                commandBox.runCommand("list c/done");
                commandBox.runCommand("unmark " + filteredTaskListIndex);
            }
        } else {
            if (isShort) {
                commandBox.runCommand("m " + taskBossIndex);
                commandBox.runCommand("list c/done");
                commandBox.runCommand("um " + filteredTaskListIndex);
            } else {
                commandBox.runCommand("m " + taskBossIndex);
                commandBox.runCommand("list c/done");
                commandBox.runCommand("unmark " + filteredTaskListIndex);
            }
        }

        // confirm the list now contains all previous tasks plus the task with updated details
        assertResultMessage(String.format(UnmarkCommand.MESSAGE_UNMARK_TASK_DONE_SUCCESS ,
                "1. " + terminatedTask));

        commandBox.runCommand("list");
        assertTrue(taskListPanel.isListMatching(expectedAllTasks));
    }

```
###### /java/seedu/taskboss/model/task/NameTest.java
``` java
public class NameTest {

    @Test
    public void isValidName() {
        // invalid name
        assertFalse(Name.isValidName("")); // empty string

        // valid name
        assertTrue(Name.isValidName("peter jack")); // alphabets only
        assertTrue(Name.isValidName("12345")); // numbers only
        assertTrue(Name.isValidName("peter the 2nd")); // alphanumeric characters
        assertTrue(Name.isValidName("Capital Tan")); // with capital letters
        assertTrue(Name.isValidName("David Roger Jackson Ray Jr 2nd")); // long names
        assertTrue(Name.isValidName("peter*")); // contains non-alphanumeric characters
        assertTrue(Name.isValidName("^")); // only non-alphanumeric characters
    }
}
```
###### /java/seedu/taskboss/model/task/PriorityLevelTest.java
``` java
public class PriorityLevelTest {
    @Test
    public void isValidPriorityLevel() {

        // invalid priority level
        assertFalse(PriorityLevel.isValidPriorityLevel("priorityLevel")); // wrong input
        assertFalse(PriorityLevel.isValidPriorityLevel("9")); // numeric input

        // valid priority level
        assertTrue(PriorityLevel.isValidPriorityLevel(""));
        assertTrue(PriorityLevel.isValidPriorityLevel("Yes"));
        assertTrue(PriorityLevel.isValidPriorityLevel("No"));
        assertTrue(PriorityLevel.isValidPriorityLevel("Y"));
        assertTrue(PriorityLevel.isValidPriorityLevel("N"));
        assertTrue(PriorityLevel.isValidPriorityLevel("YES"));
        assertTrue(PriorityLevel.isValidPriorityLevel("NO"));
        assertTrue(PriorityLevel.isValidPriorityLevel("y"));
        assertTrue(PriorityLevel.isValidPriorityLevel("n"));
        assertTrue(PriorityLevel.isValidPriorityLevel("YeS"));
        assertTrue(PriorityLevel.isValidPriorityLevel("yES"));
        assertTrue(PriorityLevel.isValidPriorityLevel("nO"));
        assertTrue(PriorityLevel.isValidPriorityLevel("yEs"));
        assertTrue(PriorityLevel.isValidPriorityLevel("yes"));
        assertTrue(PriorityLevel.isValidPriorityLevel("no"));
        assertTrue(PriorityLevel.isValidPriorityLevel("yeS"));
        assertTrue(PriorityLevel.isValidPriorityLevel("YEs"));

    }
}
```
###### /java/seedu/taskboss/testutil/TestTask.java
``` java
    public String getAddCommandPlus() {
        StringBuilder sb = new StringBuilder();
```
###### /java/seedu/taskboss/testutil/TestTask.java
``` java
        sb.append("+ ");
        sb.append(this.getName().toString());
        sb.append(" p/" + this.getPriorityLevel().input);
```
###### /java/seedu/taskboss/testutil/TypicalTestTasks.java
``` java
            taskL = new TaskBuilder().withName("Lower costs of product").withPriorityLevel("Yes")
                    .withStartDateTime("Dec 30 2019")
                    .withEndDateTime("Jan 2 2020")
                    .withInformation("update John on new price")
                    .withRecurrence(Frequency.NONE)
                    .withCategories(AddCommand.BUILT_IN_ALL_TASKS).build();

```
