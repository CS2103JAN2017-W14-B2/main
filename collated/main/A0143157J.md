# A0143157J
###### /java/seedu/taskboss/commons/events/ui/JumpToCategoryListEvent.java
``` java
/**
 * Indicates a request to jump to the list of categories
 */
public class JumpToCategoryListEvent extends BaseEvent {
    public final Category category;

    public JumpToCategoryListEvent(Category category) {
        this.category = category;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### /java/seedu/taskboss/commons/util/StringUtil.java
``` java
    /**
     * Returns a formatted {@code taskList} ArrayList,
     * so that each ReadOnlyTask in {@code taskList} is numbered
     */
    public static String getDesiredArrayListFormat(ArrayList<ReadOnlyTask> taskList) {
        assert taskList != null;
        int i = INDEX_ONE;
        StringBuilder builder = new StringBuilder();
        for (ReadOnlyTask task : taskList) {
            builder.append(i + NUMBERING_DOT).append(task.toString());
            i++;
        }
        return builder.toString();
    }
}
```
###### /java/seedu/taskboss/logic/commands/AddCommand.java
``` java
    private final Task toAdd;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     * @throws InvalidDatesException
     * @throws BuiltInCategoryException
     */
    public AddCommand(String name, String priorityLevel, String startDateTime, String endDateTime,
            String information, String frequency, Set<String> categories)
                    throws IllegalValueException, InvalidDatesException, BuiltInCategoryException {
        final Set<Category> categorySet = new HashSet<>();

        categoriesSetUp(categories, categorySet);

        Name taskName = new Name(name);
        PriorityLevel priorityLvl = new PriorityLevel(priorityLevel);
        DateTime startDateTimeObj = new DateTime(startDateTime);
        DateTime endDateTimeObj = new DateTime(endDateTime);
        String updatedFreq = initFrequency(frequency);

        checkDatesValidity(startDateTimeObj, endDateTimeObj);

        this.toAdd = new Task(
                taskName,
                priorityLvl,
                startDateTimeObj,
                endDateTimeObj,
                new Information(information),
                new Recurrence(Frequency.valueOf(updatedFreq)),
                new UniqueCategoryList(categorySet)
        );
    }

    /**
     * Throws InvalidDatesException if {@code startDateTimeObj} is later than {@code endDateTimeObj}
     */
    private void checkDatesValidity(DateTime startDateTimeObj, DateTime endDateTimeObj) throws InvalidDatesException {
        if (startDateTimeObj.getDate() != null && endDateTimeObj.getDate() != null &&
                startDateTimeObj.getDate().after(endDateTimeObj.getDate())) {
            throw new InvalidDatesException(ERROR_INVALID_ORDER_DATES);
        }
    }

    /**
     * Initialises value of {@code frequency}
     */
    private String initFrequency(String frequency) {
        String updatedFreq;
        if (frequency.isEmpty()) {
            updatedFreq = Frequency.NONE.toString();
        } else {
            updatedFreq = frequency.toUpperCase().trim();
        }
        return updatedFreq;
    }

```
###### /java/seedu/taskboss/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException, IllegalValueException {
        assert model != null;
        try {
            model.addTask(toAdd);
            model.updateFilteredListToShowAll();
            EventsCenter.getInstance().post(new JumpToCategoryListEvent(new Category("Alltasks")));
            scrollToTask();
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (IllegalArgumentException iae) {
            throw new CommandException(Recurrence.MESSAGE_RECURRENCE_CONSTRAINTS);
        }

    }

    /**
     * Scrolls to the position of the added task
     */
    private void scrollToTask() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        int targetIndex = lastShownList.indexOf(toAdd);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex));
    }

}
```
###### /java/seedu/taskboss/logic/commands/EditCommand.java
``` java
    /**
     * Scrolls to the position of the task
     */
    private void scrollToTask(ReadOnlyTask task) {
        List<ReadOnlyTask> lastShownList =  model.getFilteredTaskList();
        int targetIndex = lastShownList.indexOf(task);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex));
    }

```
###### /java/seedu/taskboss/logic/commands/exceptions/InvalidDatesException.java
``` java
/**
 * Signals an error caused by having a task's end date
 * earlier than its start date
 */
public class InvalidDatesException extends Exception {
    public InvalidDatesException(String message) {
        super(message);
    }
}
```
###### /java/seedu/taskboss/logic/commands/RenameCategoryCommand.java
``` java
/**
 * Renames an existing category in TaskBoss.
 */
public class RenameCategoryCommand extends Command {

    private final Logger logger = LogsCenter.getLogger(RenameCategoryCommand.class);

    private static final String EMPTY_STRING = "";
    public static final String COMMAND_WORD = "name";
    public static final String COMMAND_WORD_SHORT = "n";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "/" + COMMAND_WORD_SHORT
            + ": Renames an existing category.\n"
            + "Parameters: OLD_CATEGORY_NAME NEW_CATEGORY_NAME.\n"
            + "Example: " + COMMAND_WORD + " Work Workplace"
            + " || " + COMMAND_WORD_SHORT + " Home HomeSweetHome";

    public static final String MESSAGE_SUCCESS = "Category successfully renamed!";

```
###### /java/seedu/taskboss/logic/commands/RenameCategoryCommand.java
``` java
    public static final String MESSAGE_DUPLICATE_CATEGORY = "This category already exists in TaskBoss.";
    public static final String MESSAGE_DOES_NOT_EXIST_CATEGORY = "This category does not exist in TaskBoss.";

    public final String oldCategory;
    public final String newCategory;

    public RenameCategoryCommand(String oldCategory, String newCategory) {
        this.oldCategory = oldCategory;
        this.newCategory = newCategory;
    }

    @Override
    public CommandResult execute() throws CommandException, IllegalValueException {
        assert model != null;

        Category oldCategory = new Category(this.oldCategory);
        Category newCategory = new Category(this.newCategory);

        try {
            logger.info("Attempting to rename category");
            checkBuiltInCategoryViolation(oldCategory, newCategory);
            model.renameCategory(oldCategory, newCategory);
            model.updateFilteredTaskListByCategory(newCategory);
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (BuiltInCategoryException dce) {
            logger.info("User attempted to modify built-in categories' names. Throwing CommandException");
            throwCommandExceptionForBuiltInCategory(dce);
            return new CommandResult(EMPTY_STRING); // will never reach this statement
        } catch (DuplicateCategoryException e) {
            logger.info("User attempted to create duplicate categories. Returning user feedback");
            throw new CommandException(MESSAGE_DUPLICATE_CATEGORY);
        }
    }

```
###### /java/seedu/taskboss/logic/commands/SortCommand.java
``` java
/**
 * Sort tasks by start date, end date or priority.
 */
public class SortCommand extends Command {

    private static final int INDEX_FIRST_TASK = 0;
    public static final String COMMAND_WORD = "sort";
    public static final String COMMAND_WORD_SHORT = "s";

    public static final String MESSAGE_USAGE = COMMAND_WORD + "/" + COMMAND_WORD_SHORT
            + ": Sorts all tasks by either start date, end date or priority. "
            + "Parameters: SORT_TYPE (sd or ed or p)\n"
            + "Example: " + COMMAND_WORD + " sd\n"
            + "Example: " + COMMAND_WORD_SHORT + " ed";

    public static final String MESSAGE_SUCCESS = "Sorted all tasks.";

    private SortBy sortType;

    public SortCommand(SortBy sortType) {
        this.sortType = sortType;
    }

    @Override
    public CommandResult execute() throws CommandException, IllegalValueException {
        assert model != null;

        try {
            model.sortTasks(sortType);
            scrollToFirstTask();
            return new CommandResult(String.format(MESSAGE_SUCCESS));
        } catch (IllegalValueException ive) {
            throw new CommandException(ive.getMessage());
        }
    }

    /**
     * Scrolls to the position of the first task
     */
    private void scrollToFirstTask() {
        EventsCenter.getInstance().post(new JumpToListRequestEvent(INDEX_FIRST_TASK));
    }

}
```
###### /java/seedu/taskboss/logic/parser/DateTimeParser.java
``` java
/*
 * Parses date and returns a DateTime object for execution
 */
public class DateTimeParser {

    private static final int SINGLE_DATE = 1;
    private static final int INDEX_FIRST_DATEGROUP = 0;
    private static final int INDEX_FIRST_DATE = 0;
    private static final String ERROR_MULTIPLE_DATES = "Please only enter a single date.";
    private static final String REGEX_US_DATE = "(\\d{1,2})-(\\d{1,2})-((?:\\d\\d){1,2})";
    private static final String REGEX_NON_US_DATE = "$2-$1-$3";
    private static final String EMPTY_STRING = "";

    private com.joestelmach.natty.Parser nattyParser;

    public DateTimeParser() {
        this.nattyParser = new com.joestelmach.natty.Parser();
    }

    /**
     * Returns if a given {@code String date} is a valid date input
     * Used in DateTime class
     */
    public boolean isParseable(String date) {
        List<DateGroup> tempDateGroupList = this.nattyParser.parse(date);
        int numDates = countDates(tempDateGroupList);

        return numDates >= SINGLE_DATE;
    }

    /**
     * Parses a given {@code String date}
     * @return List<DateGroup>
     */
    public List<DateGroup> parse(String date) {
        String currentDate = date;
        if (Locale.getDefault().equals(Locale.US)) {
            currentDate = date.replaceAll(REGEX_US_DATE, REGEX_NON_US_DATE);
        }

        List<DateGroup> dateGroupList = this.nattyParser.parse(currentDate);
        return dateGroupList;
    }

    /**
     * Calls helper parse() to parse a given {@code String date}
     * and verifies accepted date input
     * @return parsed DateTime object
     */
    public DateTime parseDate(String date) throws IllegalValueException {
        if (date.equals("Optional[" + EMPTY_STRING + "]")) {
            return new DateTime(EMPTY_STRING);
        }

        List <DateGroup> dateGroupList = parse(date);
        int numDates = countDates(dateGroupList);

        checkDateValidity(numDates);

        DateGroup dateGroup = dateGroupList.get(INDEX_FIRST_DATEGROUP);

        return new DateTime(dateGroup.getDates().get(INDEX_FIRST_DATE), dateGroup.isDateInferred(),
                dateGroup.isTimeInferred());
    }

    /**
     * Checks if {@code numDates} have more than one date
     * @throws IllegalValueException
     */
    private void checkDateValidity(int numDates) throws IllegalValueException {
        if (numDates > SINGLE_DATE) {
            throw new IllegalValueException(ERROR_MULTIPLE_DATES);
        }
    }

    /**
     * Returns number of DateGroup present in a given {@code List<DateGroup>}
     */
    private int countDates(List<DateGroup> dateGroups) {
        int numTotalDates = 0;
        for (DateGroup dateGroup : dateGroups) {
            numTotalDates += dateGroup.getDates().size();
        }
        return numTotalDates;
    }

    // for testing
    public static String getMultipleDatesError() {
        return ERROR_MULTIPLE_DATES;
    }
}
```
###### /java/seedu/taskboss/logic/parser/EditCommandParser.java
``` java
    /**
     * Sets recurrence as NONE if user input is "edit INDEX r/",
     * @throws IllegalValueException
     */
    private void processRecurrence(String args, ArgumentTokenizer argsTokenizer, EditTaskDescriptor editTaskDescriptor)
            throws IllegalValueException {
        if (args.contains(PREFIX_RECURRENCE.getPrefix()) &&
                argsTokenizer.getValue(PREFIX_RECURRENCE).get().equals(EMPTY_STRING)) {
            editTaskDescriptor.setRecurrence(Optional.of(new Recurrence(Frequency.NONE)));
        } else {
            editTaskDescriptor.setRecurrence(ParserUtil.parseRecurrence
                    (argsTokenizer.getValue(PREFIX_RECURRENCE)));
        }
    }

    /**
     * Removes the current endDateTime if user input is "edit INDEX ed/",
     * @throws IllegalValueException
     */
    private void processEndDateTime(String args, EditTaskDescriptor editTaskDescriptor,
            Optional<DateTime> endDateTimeOp) throws IllegalValueException {
        if (!endDateTimeOp.isPresent() && args.contains(PREFIX_END_DATE.getPrefix())) {
            editTaskDescriptor.setEndDateTime(Optional.of(new DateTime(EMPTY_STRING)));
        } else {
            editTaskDescriptor.setEndDateTime(endDateTimeOp);
        }
    }

    /**
     * Removes the current startDateTime if user input is "edit INDEX sd/",
     * @throws IllegalValueException
     */
    private void processStartDateTime(String args, EditTaskDescriptor editTaskDescriptor,
            Optional<DateTime> startDateTimeOp) throws IllegalValueException {
        if (!startDateTimeOp.isPresent() && args.contains(PREFIX_START_DATE.getPrefix())) {
            editTaskDescriptor.setStartDateTime(Optional.of(new DateTime(EMPTY_STRING)));
        } else {
            editTaskDescriptor.setStartDateTime(startDateTimeOp);
        }
    }

```
###### /java/seedu/taskboss/logic/parser/FindCommandParser.java
``` java
    /**
     * Returns a Natty-parsed String that represents the date that the keywords suggest.
     * Three possible cases:
     * 1. User only enters time (e.g 9am / 5.30pm)
     * 2. User only enters month (e.g feb / december)
     * 3. User enters a date regardless of the presence of time
     * @throws IllegalValueException
     */
    private String parseFindDates(String keywords) throws IllegalValueException {
        DateTime parsedFormattedDateTime = new DateTime(keywords);

        // user only enters time
        if (parsedFormattedDateTime.isDateInferred() && !parsedFormattedDateTime.isTimeInferred()) {
            keywords = extractSubstring(parsedFormattedDateTime, INDEX_TIME_START_POSITION,
                    parsedFormattedDateTime.value.length());

        // user only enters month
        } else if (!keywords.trim().contains(WHITESPACE)
                && !oneWordDays.containsKey(keywords.toLowerCase())) {
            keywords = extractSubstring(parsedFormattedDateTime, INDEX_MONTH_START_POSITION,
                    INDEX_MONTH_END_POSITION + 1);

        // user enters date with or without time
        } else {
            keywords = parsedFormattedDateTime.value;
        }
        return keywords;
    }

    /**
     * Returns the extracted substring from the parsed {@code formattedDateTime}
     */
    private String extractSubstring(DateTime formattedDateTime, int substringStartPos,
            int substringEndPos) {
        return formattedDateTime.value.substring(substringStartPos, substringEndPos);
    }

    /**
     * Returns true if keyword is a {@code String} time
     */
    private boolean hasAmOrPm(String keyword) {
        return (keyword.toLowerCase().contains("am") ||
                keyword.toLowerCase().contains("pm"));
    }

    /**
     * Helper function for parseFindDates().
     * Initializes the {@code oneWordDays} HashMap so that we can distinguish
     * in O(1) time if a one-word keyword is a natural language day
     * or a month
     */
    private void initOneWordDay() {
        oneWordDays.put("today", "today");
        oneWordDays.put("tomorrow", "tomorrow");
        oneWordDays.put("tmr", "tomorrow");
        oneWordDays.put("yesterday", "yesterday");
        oneWordDays.put("ytd", "yesterday");
        oneWordDays.put("now", "today");
    }

```
###### /java/seedu/taskboss/logic/parser/ParserUtil.java
``` java
    /**
     * Returns the specified sort type in the {@code command} if it is a valid sort type
     * Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<String> parseSortType(String command) {
        final Matcher matcher = SORT_TYPE_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String sortType = matcher.group("sortType");
        if (sortType == null) {
            return Optional.empty();
        }
        return Optional.of(sortType);
    }

    /**
     * Splits {@code command} by whitespace as delimiter into a {@code String[]}
     * Returns the {@code String[]}.
     */
    public static String[] parseRenameCategory(String command) {
        String trimmedCommand = command.trim();
        String[] categories = trimmedCommand.split(ALL_WHITESPACE);
        return categories;
    }

```
###### /java/seedu/taskboss/logic/parser/ParserUtil.java
``` java
    /**
     * Parses an {@code Optional<String>} dateTime into an {@code Optional<DateTime>}
     * if {@code dateTime} is present.
     * @throws IllegalValueException
     */
    public static Optional<DateTime> parseDateTime(Optional<String> dateTime) throws IllegalValueException {
        assert dateTime != null;

        if (dateTime.isPresent()) {
            DateTimeParser dateParser = new DateTimeParser();
            DateTime dt = dateParser.parseDate(dateTime.toString().trim());
            return Optional.of(dt);
        } else {
            return Optional.empty();
        }
    }

    /**
     * Parses a {@code Optional<String> frequency} into an {@code Optional<Recurrence>}
     * if {@code recurrence} is present.
     */
    public static Optional<Recurrence> parseRecurrence(Optional<String> frequency) throws
        IllegalValueException, IllegalArgumentException {
        assert frequency != null;
        return frequency.isPresent() ? Optional.of(new Recurrence(Frequency
                .valueOf(frequency.get().toUpperCase().trim()))) : Optional.empty();
    }

```
###### /java/seedu/taskboss/logic/parser/RenameCategoryCommandParser.java
``` java
/**
 * Parses input arguments and creates a new RenameCategoryCommand object
 */
public class RenameCategoryCommandParser {

    private static final int NUM_NO_CATEGORIES = 0;
    private static final int NUM_CATEGORIES_PARAM = 2;

    private static final int INDEX_OLD_CATEGORY = 0;
    private static final int INDEX_NEW_CATEGORY = 1;

    private static final String FORMAT_ALPHANUMERIC = "[A-Za-z0-9]+";

    public static final String ERROR_NON_ALPHANUMERIC = "Category names should be alphanumeric.";
    public static final String ERROR_SAME_FIELDS = "Old and new category names are the same.";

    public Command parse(String args) {
        String[] categories = ParserUtil.parseRenameCategory(args);
        if (categories.length != NUM_CATEGORIES_PARAM || categories.length == NUM_NO_CATEGORIES) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RenameCategoryCommand.MESSAGE_USAGE));
        }
        String oldCategory = categories[INDEX_OLD_CATEGORY];
        String newCategory = categories[INDEX_NEW_CATEGORY];

        if (!oldCategory.matches(FORMAT_ALPHANUMERIC) ||
            !newCategory.matches(FORMAT_ALPHANUMERIC)) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ERROR_NON_ALPHANUMERIC));
        } else if (oldCategory.equals(newCategory)) {
            return new IncorrectCommand(ERROR_SAME_FIELDS);
        }

        return new RenameCategoryCommand(oldCategory, newCategory);
    }
}
```
###### /java/seedu/taskboss/logic/parser/SortCommandParser.java
``` java
/**
 * Parses input arguments and creates a new SortCommand object
 */
public class SortCommandParser {

    private static final String SORT_PARAM_START_DATE_TIME = "sd";
    private static final String SORT_PARAM_END_DATE_TIME = "ed";
    private static final String SORT_PARAM_PRIORITY_LEVEL = "p";

    /**
     * Parses the given {@code String} of arguments in the context of the SortCommand
     * and returns an SortCommand object for execution.
     */
    public Command parse(String args) {
        Optional<String> sortTypeOp = ParserUtil.parseSortType(args);
        if (!sortTypeOp.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SortCommand.MESSAGE_USAGE));
        }

        String sortType = sortTypeOp.get();
        switch(sortType) {
        case SORT_PARAM_START_DATE_TIME:
            return new SortCommand(SortBy.START_DATE_TIME);

        case SORT_PARAM_END_DATE_TIME:
            return new SortCommand(SortBy.END_DATE_TIME);

        case SORT_PARAM_PRIORITY_LEVEL:
            return new SortCommand(SortBy.PRIORITY_LEVEL);

        default:
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SortCommand.MESSAGE_USAGE));
        }
    }
}
```
###### /java/seedu/taskboss/model/category/UniqueCategoryList.java
``` java
    /**
     * Replaces a Category in the list.
     * On client-side, this operation is to rename {@code oldCategory}.
     * @throws IllegalValueException
     */
    public void replace(Category newCategory, Category oldCategory) throws IllegalValueException {
        for (Category category : this) {
            if (category.categoryName.equals(new Category(oldCategory.categoryName))) {
                this.remove(oldCategory);
            }
        }
        this.add(newCategory);
    }

```
###### /java/seedu/taskboss/model/Model.java
``` java
    /** Sorts the task list according to the provided sort type
     * @throws IllegalValueException */
    void sortTasks(SortBy sortType) throws IllegalValueException;

    /** Changes the name of a category of all tasks in the filtered task list
     * @throws CommandException */
    void renameCategory(Category oldCategory, Category newCategory) throws IllegalValueException, CommandException,
        DuplicateCategoryException;

```
###### /java/seedu/taskboss/model/ModelManager.java
``` java
    @Override
    public void sortTasks(SortBy sortType) throws IllegalValueException {
        assert sortType != null;
        if (taskbossHistory != null) {
            taskbossHistory.push(new TaskBoss(this.taskBoss));
        }
        this.currentSortType = sortType;
        taskBoss.sortTasks(sortType);
        indicateTaskBossChanged();
    }

```
###### /java/seedu/taskboss/model/ModelManager.java
``` java
    @Override
    public void renameCategory(Category oldCategory, Category newCategory)
            throws IllegalValueException, CommandException, DuplicateCategoryException {
        assert oldCategory != null;
        taskbossHistory.push(new TaskBoss(this.taskBoss));
        taskBoss.renameCategory(newCategory, oldCategory);
        removeCategoryFromTaskboss(oldCategory);

        undoInputList.push("rename");
        indicateTaskBossChanged();
        taskbossUndoHistory.clear();
    }

    /**
     * Returns a new recurred task with updated task dates according to the recurrence
     * of the given task
     */
    private Task createRecurredTask(ReadOnlyTask taskToMarkDone) throws IllegalValueException {
        Task newRecurredTask = new Task(taskToMarkDone);
        newRecurredTask.getRecurrence().updateTaskDates(newRecurredTask);
        return newRecurredTask;
    }

```
###### /java/seedu/taskboss/model/task/DateTime.java
``` java
public class DateTime {

    public static final String ERROR_INVALID_DATE = "Failed to understand given date.";
    public static final String MESSAGE_DATE_CONSTRAINTS = "Task dates format should be in dd-mm-yyyy,"
            + " or word format like 5pm tomorrow, " + "and does not accept doubles.";
    private static final String EMPTY_STRING = "";
    private static final String NEWLINE = "\n";

    public String value;
    private boolean isDateInferred;
    private boolean isTimeInferred;
    private Date date;
    private DateTimeParser dtParser;

    public DateTime(String date) throws IllegalValueException {
        assert date != null;

        this.dtParser = new DateTimeParser();
        this.isDateInferred = false;
        this.isTimeInferred = false;
        this.date = null;
        String trimmedDate = date.trim();
        this.value = trimmedDate;
        if (!isValidDateTime(trimmedDate)) {
            throw new IllegalValueException(ERROR_INVALID_DATE + NEWLINE + MESSAGE_DATE_CONSTRAINTS);
        }

        if (trimmedDate.equals(EMPTY_STRING)) {
            this.value = EMPTY_STRING;
        } else {
            parseDateTime(trimmedDate);
            formatDateTime();
        }
    }

    public DateTime(Date dateTime, boolean isDateInferred, boolean isTimeInferred) {
        this.date = dateTime;
        this.isDateInferred = isDateInferred;
        this.isTimeInferred = isTimeInferred;
        value = this.date.toString();
    }

    /**
     * Returns if a given string is a valid date input.
     *
     * @throws IllegalValueException
     */
    private boolean isValidDateTime(String date) throws IllegalValueException {
        if (date.equals(EMPTY_STRING)) {
            return true;
        } else {
            return dtParser.isParseable(date);
        }
    }

    public void parseDateTime(String date) throws IllegalValueException {
        if (date.equals(EMPTY_STRING)) {
            return;
        }
        DateTime dateTime = dtParser.parseDate(date);
        this.date = dateTime.getDate();
        this.setIsDateInferred(dateTime.isDateInferred);
        this.setIsTimeInferred(dateTime.isTimeInferred);
    }

    /**
     * Format the current natty-parsed Date into a string of our intended format
     * i.e May 19, 2017 8:30 PM
     */
    public String formatDateTime() {
        SimpleDateFormat sdfGeneral = new SimpleDateFormat("MMM dd, yyyy h:mm aa");
        SimpleDateFormat sdfNoTime = new SimpleDateFormat("MMM dd, yyyy");
        // No time provided by user
        if (this.isTimeInferred()) {
            this.value = sdfNoTime.format(this.date);
        } else if (!this.value.equals(EMPTY_STRING)) {
            this.value = sdfGeneral.format(this.date);
        }

        return this.value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateTime // instanceof handles nulls
                        && this.value.equals(((DateTime) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public boolean isDateInferred() {
        return isDateInferred;
    }

    public boolean isTimeInferred() {
        return isTimeInferred;
    }

    public void setIsDateInferred(boolean status) {
        this.isDateInferred = status;
    }

    public void setIsTimeInferred(boolean status) {
        this.isTimeInferred = status;
    }

    public Date getDate() {
        return date;
    }

}
```
###### /java/seedu/taskboss/model/task/Recurrence.java
``` java
public class Recurrence {

    private static final String EMPTY_STRING = "";
    private static final String CATEGORY_DONE = "Done";
    private static final int AMOUNT_ONE = 1;

    public static final String MESSAGE_RECURRENCE_CONSTRAINTS =
            "Task recurrence is NONE by default,"
            + " and can be DAILY, WEEKLY, MONTHLY or YEARLY.";

    public enum Frequency {
        DAILY, WEEKLY, MONTHLY, YEARLY, NONE
    }

    private Frequency frequency;

    public Recurrence(Frequency frequency) throws IllegalArgumentException {
        assert frequency != null;
        if (frequency.toString().equals(EMPTY_STRING)) {
            this.frequency = Frequency.NONE;
        } else {
            this.frequency = frequency;
        }
    }

    /**
     * Marks a recurring {@code task} undone and
     * updates {@code task} dates according to the recurrence of the {@code task}
     * @throws IllegalValueException
     */
    public void updateTaskDates(Task task) throws IllegalValueException {
        markTaskUndone(task);

        Date startDate = task.getStartDateTime().getDate();
        Date endDate = task.getEndDateTime().getDate();
        SimpleDateFormat startSdfFormat = initSimpleDateFormat(task.getStartDateTime());
        SimpleDateFormat endSdfFormat = initSimpleDateFormat(task.getEndDateTime());
        boolean isStartDate = true;

        switch(this.frequency) {
        case DAILY:
            updateDailyRecur(task, startDate, endDate, startSdfFormat, endSdfFormat, isStartDate);
            break;

        case WEEKLY:
            updateWeeklyRecur(task, startDate, endDate, startSdfFormat, endSdfFormat, isStartDate);
            break;

        case MONTHLY:
            updateMonthlyRecur(task, startDate, endDate, startSdfFormat, endSdfFormat, isStartDate);
            break;

        case YEARLY:
            updateYearlyRecur(task, startDate, endDate, startSdfFormat, endSdfFormat, isStartDate);
            break;

        case NONE:
            break; // do nothing

        default:
            throw new IllegalValueException(Recurrence.MESSAGE_RECURRENCE_CONSTRAINTS);
        }
    }

    /**
     * Update task dates {@code startDate} and {@code endDate} by incrementing a year if they are present
     * @throws IllegalValueException
     */
    private void updateYearlyRecur(Task task, Date startDate, Date endDate, SimpleDateFormat startSdfFormat,
            SimpleDateFormat endSdfFormat, boolean isStartDate) throws IllegalValueException {
        if (startDate != null) {
            updateDateTime(Frequency.YEARLY, task, startSdfFormat, isStartDate);
        }
        if (endDate != null) {
            updateDateTime(Frequency.YEARLY, task, endSdfFormat, !isStartDate);
        }
    }

    /**
     * Update task dates {@code startDate} and {@code endDate} by incrementing a month if they are present
     * @throws IllegalValueException
     */
    private void updateMonthlyRecur(Task task, Date startDate, Date endDate, SimpleDateFormat startSdfFormat,
            SimpleDateFormat endSdfFormat, boolean isStartDate) throws IllegalValueException {
        if (startDate != null) {
            updateDateTime(Frequency.MONTHLY, task, startSdfFormat, isStartDate);
        }
        if (endDate != null) {
            updateDateTime(Frequency.MONTHLY, task, endSdfFormat, !isStartDate);
        }
    }

    /**
     * Update task dates {@code startDate} and {@code endDate} by incrementing a weekly if they are present
     * @throws IllegalValueException
     */
    private void updateWeeklyRecur(Task task, Date startDate, Date endDate, SimpleDateFormat startSdfFormat,
            SimpleDateFormat endSdfFormat, boolean isStartDate) throws IllegalValueException {
        if (startDate != null) {
            updateDateTime(Frequency.WEEKLY, task, startSdfFormat, isStartDate);
        }
        if (endDate != null) {
            updateDateTime(Frequency.WEEKLY, task, endSdfFormat, !isStartDate);
        }
    }

    /**
     * Update {@code task} dates {@code startDate} and {@code endDate} by incrementing a day if they are present
     * @throws IllegalValueException
     */
    private void updateDailyRecur(Task task, Date startDate, Date endDate, SimpleDateFormat startSdfFormat,
            SimpleDateFormat endSdfFormat, boolean isStartDate) throws IllegalValueException {
        if (startDate != null) {
            updateDateTime(Frequency.DAILY, task, startSdfFormat, isStartDate);
        }
        if (endDate != null) {
            updateDateTime(Frequency.DAILY, task, endSdfFormat, !isStartDate);
        }
    }

    /**
     * Update a {@code task} date based on the specified {@code frequency}
     * @throws IllegalValueException
     */
    private void updateDateTime(Frequency frequency, Task task, SimpleDateFormat sdfFormat, boolean isStartDate)
            throws IllegalValueException {
        if (isStartDate) {
            Date startDate = task.getStartDateTime().getDate();
            Calendar startCalendar = addFrequencyToCalendar(startDate, frequency);
            setDateTime(startCalendar, task, sdfFormat, true);
        } else {
            Date endDate = task.getEndDateTime().getDate();
            Calendar endCalendar = addFrequencyToCalendar(endDate, frequency);
            setDateTime(endCalendar, task, sdfFormat, false);
        }
    }

    /**
     * Set the start/end DateTime of a given {@code task} with the Date
     * extracted from {@code calendar}, based on its original SimpleDateFormat {@code desiredFormat}
     * @throws IllegalValueException
     */
    private void setDateTime(Calendar calendar, Task task,
            SimpleDateFormat desiredFormat, boolean isStartDate) throws IllegalValueException {
        String dateInString = desiredFormat.format(calendar.getTime());
        if (isStartDate) {
            task.setStartDateTime(new DateTime(dateInString));
        } else {
            task.setEndDateTime(new DateTime(dateInString));
        }
    }

    /**
     * Constructs a Calendar and adds the corresponding
     * frequency to the Calendar with the given {@code date}.
     */
    private Calendar addFrequencyToCalendar(Date date, Frequency freq) {
        Calendar calendar = initCalendar(date);
        if (freq == Frequency.DAILY) {
            addDayToCalendar(calendar);
        } else if (freq == Frequency.WEEKLY) {
            addWeekToCalendar(calendar);
        } else if (freq == Frequency.MONTHLY) {
            addMonthToCalendar(calendar);
        } else if (freq == Frequency.YEARLY) {
            addYearToCalendar(calendar);
        }
        return calendar;
    }

    /**
     * Adds one day to the {@code calendar}.
     */
    private void addDayToCalendar(Calendar calendar) {
        calendar.add(Calendar.DATE, AMOUNT_ONE);
    }

    /**
     * Adds one week to the {@code calendar}.
     */
    private void addWeekToCalendar(Calendar calendar) {
        calendar.add(Calendar.WEEK_OF_YEAR, AMOUNT_ONE);
    }

    /**
     * Adds one month to the {@code calendar}.
     */
    private void addMonthToCalendar(Calendar calendar) {
        calendar.add(Calendar.MONTH, AMOUNT_ONE);
    }

    /**
     * Adds one year to the {@code calendar}.
     */
    private void addYearToCalendar(Calendar calendar) {
        calendar.add(Calendar.YEAR, AMOUNT_ONE);
    }

    /**
     * Returns an initialised calendar with the given Date
     */
    private Calendar initCalendar(Date date) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        return calendar;
    }

    /**
     * Returns the corresponding SimpleDateFormat of the given DateTime
     */
    private SimpleDateFormat initSimpleDateFormat(DateTime dateTime) {
        if (dateTime.isTimeInferred()) {
            return new SimpleDateFormat("MMM dd, yyyy");
        } else {
            return new SimpleDateFormat("MMM dd, yyyy h:mm aa");
        }
    }

    /**
     * Marks a task as undone (i.e removing it from "Done" category)
     * @throws IllegalValueException
     */
    private void markTaskUndone(Task task) throws IllegalValueException {
        UniqueCategoryList newCategoryList = new UniqueCategoryList();
        for (Category category : task.getCategories()) {
            if (!category.equals(CATEGORY_DONE)) {
                newCategoryList.add(category);
            }
        }
        task.setCategories(newCategoryList);
    }

    public boolean isRecurring() {
        return this.frequency != Frequency.NONE;
    }

    @Override
    public String toString() {
        switch(this.frequency) {
        case DAILY :
            return "DAILY";
        case WEEKLY:
            return "WEEKLY";
        case MONTHLY:
            return "MONTHLY";
        case YEARLY:
            return "YEARLY";
        default:
            return "NONE";
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Recurrence // instanceof handles nulls
                && this.frequency.equals(((Recurrence) other).frequency)); // state check
    }

    /**
     * Returns true if a given string is a valid task recurrence.
     * Created for testing purposes only.
     */
    public static boolean isValidRecurrence(String inputFreq) {
        String freq = inputFreq.toUpperCase().trim();
        return (freq.equals("DAILY") || freq.equals("WEEKLY") ||
                freq.equals("MONTHLY") || freq.equals("YEARLY") ||
                freq.equals("NONE") || freq.equals(EMPTY_STRING));
    }
}
```
###### /java/seedu/taskboss/model/task/Task.java
``` java
    public void setStartDateTime(DateTime startDateTime) {
        assert startDateTime != null;
        this.startDateTime = startDateTime;
    }

    @Override
    public DateTime getStartDateTime() {
        return startDateTime;
    }

    public void setEndDateTime(DateTime endDateTime) {
        assert endDateTime != null;
        this.endDateTime = endDateTime;
    }

    @Override
    public DateTime getEndDateTime() {
        return endDateTime;
    }

```
###### /java/seedu/taskboss/model/task/Task.java
``` java
    public void setRecurrence(Recurrence recurrence) {
        assert recurrence != null;
        this.recurrence = recurrence;
    }

    @Override
    public Recurrence getRecurrence() {
        return this.recurrence;
    }

    @Override
    public boolean isRecurring() {
        return this.recurrence.isRecurring();
    }

```
###### /java/seedu/taskboss/model/task/UniqueTaskList.java
``` java
    public enum SortBy {
        START_DATE_TIME, END_DATE_TIME, PRIORITY_LEVEL
    }

    /**
     * Sorts tasks based on the specified sort type.
     * Start and end dates are sorted in ascending order,
     * whereas priority level is sorted in descending order
     * (i.e tasks with high priority will be listed on top)
     * @throws IllegalValueException
     */
    public void sort(SortBy sortType) throws IllegalValueException {
        Comparator<ReadOnlyTask> taskCmp = null;
        switch(sortType) {
        case START_DATE_TIME:
            taskCmp =  new Comparator<ReadOnlyTask>() {
                @Override
                public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
                    Date startDate1 = task1.getStartDateTime().getDate();
                    Date startDate2 = task2.getStartDateTime().getDate();
                    return compareDateTime(startDate1, startDate2);
                }
            };
            break;

        case END_DATE_TIME:
            taskCmp = new Comparator<ReadOnlyTask> () {
                @Override
                public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
                    Date endDate1 = task1.getEndDateTime().getDate();
                    Date endDate2 = task2.getEndDateTime().getDate();
                    return compareDateTime(endDate1, endDate2);
                }
            };
            break;

        case PRIORITY_LEVEL:
            taskCmp = new Comparator<ReadOnlyTask> () {
                @Override
                public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
                    String priorityLevel1 = task1.getPriorityLevel().toString();
                    String priorityLevel2 = task2.getPriorityLevel().toString();
                    return comparePriorityLevel(priorityLevel1, priorityLevel2);
                }

            };
            break;

        default:
            throw new IllegalValueException(SortCommand.MESSAGE_USAGE);
        }

        FXCollections.sort(internalList, taskCmp);
    }

    /**
     * Compares {@code date1} with {@code date2}.
     * Earlier date will take precedence.
     * A null value is seen as having a lower precedence than a non-null date.
     */
    private int compareDateTime(Date date1, Date date2) {
        if (date1 == null &&
                date2 == null) {
            return 0;
        } else if (date1 == null) {
            return 1;
        } else if (date2 == null) {
            return -1;
        } else {
            return date1.compareTo(date2);
        }
    }

    /**
     * Compares {@code priorityLevel1} with {@code priorityLevel2}.
     * High priority will take precedence.
     */
    private int comparePriorityLevel(String priorityLevel1, String priorityLevel2) {
        if (priorityLevel1.equals(priorityLevel2)) {
            return 0;
        } else if (priorityLevel1.equals(PriorityLevel.PRIORITY_HIGH_VALUE)) {
            return -1;
        } else if (priorityLevel2.equals(PriorityLevel.PRIORITY_HIGH_VALUE)) {
            return 1;
        } else {
            return 0;
        }
    }

```
###### /java/seedu/taskboss/model/task/UniqueTaskList.java
``` java
    /**
     * Renames a certain category for all tasks in this category.
     * @throws IllegalValueException
     * @throws CommandException
     */
    public void renameCategory(Category oldCategory, Category newCategory) throws IllegalValueException,
                                                                                CommandException {
        assert oldCategory != null;

        boolean isOldCategoryFound = false;

        for (Task task : this) {
            UniqueCategoryList targetCategoryList = task.getCategories();
            UniqueCategoryList newCategoryList = new UniqueCategoryList();
            try {
                isOldCategoryFound = initNewCategoryList(oldCategory, newCategory, isOldCategoryFound,
                        targetCategoryList, newCategoryList);
            } catch (DuplicateCategoryException dce) {
                throw new DuplicateCategoryException();
            }
            task.setCategories(newCategoryList);
        }
        errorDoesNotExistDetect(oldCategory, isOldCategoryFound);
    }

    /**
     * Initialises {@code newCategoryList} and returns true if {@code oldCategory}
     * is found in {@code targetCategoryList}
     * @throws IllegalValueException, DuplicateCategoryException
     */
    private boolean initNewCategoryList(Category oldCategory, Category newCategory, boolean isOldCategoryFound,
            UniqueCategoryList targetCategoryList, UniqueCategoryList newCategoryList)
            throws IllegalValueException, DuplicateCategoryException {
        boolean isFound = isOldCategoryFound;
        for (Category category : targetCategoryList) {
            if (category.equals(oldCategory)) {
                isFound = true;
                newCategoryList.add(newCategory);
            } else {
                newCategoryList.add(category);
            }
        }
        return isFound;
    }

```
###### /java/seedu/taskboss/model/TaskBoss.java
``` java
    /**
     * Sorts tasks in TaskBoss according to these sort types:
     * - start date and time
     * - end date and time
     * @throws IllegalValueException
     */
    public void sortTasks(SortBy sortType) throws IllegalValueException {
        tasks.sort(sortType);
    }

//// category-level operations

    public void addCategory(Category t) throws IllegalValueException {
        categories.add(t);
    }

```
###### /java/seedu/taskboss/ui/CategoryCard.java
``` java
/**
 * A ui for each category card that is contained in CategoryListPanel
 */
public class CategoryCard extends UiPart<Region> {

    private static final String FXML = "CategoryCard.fxml";

    @FXML
    private Label categoryText;

    @FXML
    private Label categoryTaskCount;

    @FXML
    private Rectangle taskCountRectangle;

    public CategoryCard(Category category, int taskCount) {
        super(FXML);
        initCategories(category, taskCount);
    }

    private void initCategories(Category category, int taskCount) {
        categoryText.setText(category.categoryName);
        categoryTaskCount.setText(Integer.toString(taskCount));
        if (category.categoryName.equals("Alltasks") || category.categoryName.equals("Done")) {
            taskCountRectangle.setFill(Color.web("F26177"));
        }
    }
}
```
###### /java/seedu/taskboss/ui/CategoryListPanel.java
``` java
/**
 * Panel containing the list of categories.
 */
public class CategoryListPanel extends UiPart<Region> {

    private final Logger logger = LogsCenter.getLogger(CategoryListPanel.class);

    private static final int AMOUNT_ONE = 1;
    private static final String FXML = "CategoryListPanel.fxml";
    private ObservableList<ReadOnlyTask> tasks;
    private ObservableList<Category> categories;
    private HashMap<Category, Integer> categoryHm;

    @FXML
    private ListView<Category> categoryListView;

    public CategoryListPanel(AnchorPane categoryListPlaceholder, ObservableList<ReadOnlyTask> taskList) {
        super(FXML);
        tasks = taskList;
        syncCategoryTaskCount();
        addToPlaceholder(categoryListPlaceholder);
        registerAsAnEventHandler(this);
        consumeMouseClick();
    }

    /**
     * Syncs each category task count in the CategoryListPanel with
     * {@code ObservableList<ReadOnlyTask>} tasks
     */
    public void syncCategoryTaskCount() {
        categoryHm = new HashMap<Category, Integer>();

        for (ReadOnlyTask task : tasks) {
            if (task.getCategories().contains(Category.done)) {
                updateCategoryHashMap(Category.done, true);
            } else {
                for (Category category : task.getCategories()) {
                    updateCategoryHashMap(category, false);
                }
            }
        }
        setConnections();
    }

    /**
     * Updates {@code HashMap<Category, Integer>} categoryHm accordingly
     * after checking boolean {@code isDoneCategory}
     */
    private void updateCategoryHashMap(Category category, boolean isDoneCategory) {
        if (isDoneCategory) {
            putCategoryInHashMap(Category.done);
        } else {
            putCategoryInHashMap(category);
        }
    }

    /**
     * Adds one to the value of {@code category} in its corresponding {@code categoryHm} <key, pair> entry
     * if it is present, else create the entry and set its value as one.
     */
    private void putCategoryInHashMap(Category category) {
        if (!categoryHm.containsKey(category)) {
            categoryHm.put(category, AMOUNT_ONE);
        } else {
            categoryHm.put(category, categoryHm.get(category) + AMOUNT_ONE);
        }
    }

    /**
     * Initializes {@code ObservableList<Category>} categories
     */
    private ObservableList<Category> initCategories() {
        categories = FXCollections.observableArrayList();
        for (Entry<Category, Integer> entry : categoryHm.entrySet()) {
            if (entry.getValue() > 0) {
                categories.add(entry.getKey());
            }
        }
        sortCategoryList();
        return categories;
    }

    /**
     * Sort category list according to alphabetical order,
     * but with Alltasks always on top, and Done always at the bottom.
     */
    private void sortCategoryList() {
        Comparator<Category> categoryCmp = new Comparator<Category>() {
            @Override
            public int compare(Category o1, Category o2) {
                if (o1.categoryName.equals("Alltasks")) {
                    return -1;
                } else if (o2.categoryName.equals("Alltasks")) {
                    return 1;
                } else if (o1.categoryName.equals("Done")) {
                    return 1;
                } else if (o2.categoryName.equals("Done")) {
                    return -1;
                } else {
                    return o1.categoryName.compareTo(o2.categoryName);
                }
            }
        };

        FXCollections.sort(categories, categoryCmp);
    }

    /**
     * Subscribe to changes in TaskBoss and
     * updates categories in the CategoryListPanel accordingly
     */
    @Subscribe
    public void handleTaskBossChangedEvent(TaskBossChangedEvent tmce) {
        syncCategoryTaskCount();
        initCategories();
        setConnections();
    }

    private void setConnections() {
        categories = initCategories();
        categoryListView.setItems(categories);
        categoryListView.setCellFactory(listView -> new CategoryListViewCell());
    }

    /**
     * Sets the task list to the given task list
     */
    public void setTaskList(ObservableList<ReadOnlyTask> taskList) {
        this.tasks = taskList;
    }

    /**
     * Sets the category list to the given category list
     */
    public void setCategoryList(ObservableList<Category> categoryList) {
        this.categories = categoryList;
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(getRoot());
    }



    /**
     * Scrolls to the specified category by the user
     * using list or list c/ commands.
     */
    public void scrollTo(Category currCategory) {
        Platform.runLater(() -> {
            int index = 0;
            for (Category category : categories) {
                if (category.equals(currCategory)) {
                    break;
                }
                index++;
            }
            categoryListView.scrollTo(index);
            categoryListView.getSelectionModel().clearAndSelect(index);
        });
    }

    /**
     * Consumes any mouse click on categories in the categoryListPanel
     */
    private void consumeMouseClick() {
        categoryListView.addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {
            public void handle(MouseEvent event) {
                logger.info("Mouse clicked on CategoryListPanel");
                event.consume();
            }
        });
    }

    class CategoryListViewCell extends ListCell<Category> {

        @Override
        protected void updateItem(Category category, boolean empty) {
            super.updateItem(category, empty);

            if (empty || category == null) {
                setGraphic(null);
                setText(null);
            } else {
                Integer taskCount = categoryHm.get(category);
                setGraphic(new CategoryCard(category, taskCount).getRoot());
            }
        }
    }

}
```
###### /java/seedu/taskboss/ui/MainWindow.java
``` java
    /**
     * Initialises {@code categoryListPanel}
     */
    private void initCategoryListPanel() {
        categoryListPanel = new CategoryListPanel(getCategoryListPlaceholder(), logic.getFilteredTaskList());
        categoryListPanel.setTaskList(logic.getTaskBoss().getTaskList());
        categoryListPanel.setCategoryList(logic.getTaskBoss().getCategoryList());
        categoryListPanel.syncCategoryTaskCount();
    }

```
###### /java/seedu/taskboss/ui/TaskCard.java
``` java
    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        initOverdueTaskCss(task);
        initName(task);
        initId(displayedIndex);
        initPriority(task);
        initStartDateTime(task);
        initEndDateTime(task);
        initInformation(task);
        initRecurrence(task);
        initCategories(task);
    }

    /**
     * Initialises CSS properties for a task that is overdue
     */
    private void initOverdueTaskCss(ReadOnlyTask task) {
        Date currDate = new Date();
        if (task.getEndDateTime() == null || task.getEndDateTime().getDate() == null) {
            return;
        }
        Date taskEndDate = task.getEndDateTime().getDate();
        if (isOverdueTask(taskEndDate, currDate, task)) {
            setCardPaneOverdueStyle();
        }
    }

    /**
     * Returns true if a task is overdue by comparing current time with the task's end date time
     */
    private boolean isOverdueTask(Date taskEndDate, Date currDate, ReadOnlyTask task) {
        boolean isOverdue = currDate.after(taskEndDate);
        SimpleDateFormat sdfNoTime = new SimpleDateFormat("MMM dd, yyyy");

        if (!isOverdue) {
            return false;
        } else if (isOverdue) {
            // account for special case (taskEndDate == today) that is marked as true for .after() in the API
            // ie. ed/today (without time) should not be overdue
            if (sdfNoTime.format(taskEndDate).equals(sdfNoTime.format(currDate))
                    && !task.getEndDateTime().isTimeInferred()) {
                return true;
            } else if (!sdfNoTime.format(taskEndDate).equals(sdfNoTime.format(currDate))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Sets CSS style for the cardPane of overdue tasks
     */
    private void setCardPaneOverdueStyle() {
        cardPane.setStyle(CSS_CARDPANE_OVERDUE);
    }

    /**
     * Initialises name
     */
    private void initName(ReadOnlyTask task) {
        name.setText(task.getName().fullName);
    }

    /**
     * Initialises id
     */
    private void initId(int displayedIndex) {
        id.setText(displayedIndex + ". ");
    }

    /**
     * Initialises priority level
     */
    private void initPriority(ReadOnlyTask task) {
        PriorityLevel priority = task.getPriorityLevel();
        Image urgentImage = AppUtil.getImage(PATH_IMAGE_URGENT);
        if (priority.value.equals(PriorityLevel.PRIORITY_HIGH_VALUE)) {
            priorityLevel.setImage(urgentImage);
        } else {
            priorityLevel.setVisible(false);
        }
    }

    /**
     * Initialises start date time
     */
    private void initStartDateTime(ReadOnlyTask task) {
        String startDate = task.getStartDateTime().value;
        if (startDate.isEmpty()) {
            startDateTime.setText("Start: " + startDate);
            startDateTime.setVisible(false);
        } else {
            startDateTime.setText("Start: " + task.getStartDateTime().value);
        }
    }

    /**
     * Initialises end date time
     */
    private void initEndDateTime(ReadOnlyTask task) {
        String endDate = task.getEndDateTime().value;
        if (endDate.isEmpty()) {
            endDateTime.setText("End: " + endDate);
            endDateTime.setVisible(false);
        } else {
            endDateTime.setText("End: " + task.getEndDateTime().value);
        }
    }

    /**
     * Initialises information
     */
    private void initInformation(ReadOnlyTask task) {
        information.setText(task.getInformation().value);
    }

    /**
     * Initialises recurrence
     */
    private void initRecurrence(ReadOnlyTask task) {
        String recurrenceType = task.getRecurrence().toString();
        if (recurrenceType.equals(RECURRENCE_NONE)) {
            recurrence.setText(task.getRecurrence().toString());
            recurrence.setVisible(false);
        } else {
            recurrence.setText(task.getRecurrence().toString());
        }
    }

    /**
     * Initialises categories
     */
    private void initCategories(ReadOnlyTask task) {
        task.getCategories().forEach(category -> categories.getChildren().add(new Label(category.categoryName)));
    }
}
```
###### /java/seedu/taskboss/ui/UiManager.java
``` java
    @Subscribe
    private void handleJumpToCategoryListEvent(JumpToCategoryListEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getCategoryListPanel().scrollTo(event.category);
    }

```
###### /resources/view/CategoryCard.fxml
``` fxml
<AnchorPane xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <HBox maxHeight="100.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
         <children>
            <StackPane>
               <children>
                  <Rectangle fx:id="taskCountRectangle" arcHeight="10.0" arcWidth="10.0" fill="#BA68C8" height="25.0" width="25.0" />
                  <Label fx:id="categoryTaskCount" text="\$categoryTaskCount" />
               </children>
               <HBox.margin>
                  <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
               </HBox.margin>
            </StackPane>
            <Label fx:id="categoryText" text="\$categoryText">
               <HBox.margin>
                  <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
               </HBox.margin>
            </Label>
         </children>
      </HBox>
   </children>
</AnchorPane>
```
###### /resources/view/CategoryListPanel.fxml
``` fxml
<VBox fillWidth="false" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
        <ListView fx:id="categoryListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
